## 模块化规范

模块化规范分为两种

- 一种是Node中自己实现的 Commonjs规范 `（require module.exports）`
- 一种是es6 Module`（import export/ export default）`

## ES6模块与CommonJS模块的差异

#### 1.CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用

> **在 CommonJS 模块中：**
>
> ​		如果你 require 了一个模块，那就相当于你执行了该文件的代码并最终获取到模块输出的 module.exports 对象的一份`拷贝，`一旦输出一个值，模块内部的变化就不会影响到这个值
>
> **在ES6模块中：**
>
> ​		JS引擎对脚本的分析的时候，遇到模块加载命令**import**，就会生成一个`只读引用`，等到脚本真正执行的时候，再根据这个`只读引用`，到被加载的那个模块里去取值
>
> ​		换句话说，只要**原始值**变了，**import**加载的值也会跟这变。因此，`ES6模块是动态引用，并且不会缓存值`

### 2.CommonJS模块是运行时加载，ES6模块是编译时输出接口

> **运行时加载：**CommonJS模块即是对象；就是在输入时`先加载整个模块，生成一个对象，然后再从这个对象上读取方法`，这种加载称为运行时加载
>
> **编译时加载：**ES6模块不是对象，而是通过`export`命令显示指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定`加载某个输出值，而不是输出整个模块`，这种加载称为编译时加载。

来看下面这样**CommonJS**的一个例子：

```js
// CommonJS模块
let { stat, exists, readFile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```

上面的代码其实是**加载了fs中所有的方法，生成了一个对象，再从这个对象上读取方法**——运行时加载

（也就是只有在**运行时才能得到这个对象，不能是编译时的静态优化**）

对比来看**Es Module**的例子：

```js
// ES6模块
import { stat, exists, readFile } from 'fs';
```

上面代码的实质是从**fs模块加载3个方法，其它方法不加载**——编译时加载

> 总结：
>
> ​	**CommonJS**加载的是一个对象（即**module.exports属性**），该对象只有在`脚本运行完`后才会生成。
>
> ​	而**ES6**模块不是对象，它的对外接口只是一种静态定义，在代码编译解析阶段就会生成。（一般在项目中结合webpack来使用）

### 3.CommonJS模块重复加载读取缓存，ES6模块重复加载不读缓存

> **CommonJS**模块：可以多次加载，但只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载直接从缓存中读取结果
>
> **ES6模块**：则不会缓存结果，每次加载都是**动态引用**新的模块

## 模块化规范的感念

- 可以把复杂的代码分成效的模块，方便维护
- 每个模块之间的内容都是相互独立的，互不影响（解决变量冲突的问题）使用自执行函数来解决

## CommonJS规范的定义

- 每个文件都是一个模块，相互独立
- 如果希望模块中的变量被别人使用，可以使用`Module.exports`导出
- 同理想使用这个模块导出的记过，使用 `require`来引用  `同步`

## 模块的分类

- Reuqire('fs')称为核心模块、内置模块，不是自己写的，也不是安装来的，是Node中自己提供的
- require('commander') 别人写的模块，通过 npm i安装的 是第三方模块
- require('./promise.js') 自定义模块，自己写的模块，引用时需要增加`相对路径和绝对路径`

