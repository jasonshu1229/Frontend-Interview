图片懒加载的意义：
虽然当代浏览器在渲染DOM树的时候，遇到img并不会阻碍DOM树的渲染（浏览器会开辟HTTP线程请求图片资源文件），但是在生成RENDER TREE后，浏览器进行渲染的时候，会把渲染树和图片一起进行绘制
遇到一些影响性能（影响页面第一次加载的速度）问题：
1. 如果请求的图片资源过多，我们同时可以开辟的HTTP线程只有6个，这样图片资源预先的加载，会影响其他资源的请求速度
2. 第一次绘制页面的时候，如果开始绘制图片，也需要消耗很多的时间，这样也影响页面第一次打开的速度
.......



所以对于这种情况：
1. 我们一般都采用图片懒加载（开始需要展示图片的位置，我们基于默认图或者一个空白的盒子占位，真实图片不加载，只有当页面第一次渲染完以及滚动到当前所在的区域时候，再去加载真实的图片）

2. 我们可以把图片base64（虽然也会慢一些，但是总比不做强很多）

    

   

1. 基于盒子模型（或者 getBoundingClientRect），我们判断出是否加载图片；在滚动条滚动中随时进行判断处理（节流）；
2. 新方案：IntersectionObserver 基于元素的监听，一体化解决懒加载问题
3. 无限下拉加载：
   基于scroll事件，监听滚动的位置，计算是否到达底部，再去加载 

### 封装插件  应该注意哪些问题

为啥要封装插件：
1. 可复用性（构建敏捷化平台，提高开发效率） 
     =>目的：尽可能适配更多的业务场景（在编写插件之前，需要调研，我们适配的需求 【本公司项目调研、市场上相对成熟的类似插件的参、自己的项目经验积累、小组讨论】）
2. 易用性
    + 我们可以支持N多的参数配置，但是做参数默认值，用户使用的时候只需要根据自己的需求配置部分即可
    + 我们还需要尽可能把功能都在内部封装好，用户无需自己去实现
    + 应该支持更多的可扩展性配置：周期函数庞大一些、样式可以修改、支持extend扩展....
    + 清晰的API使用文档
    +  更方便的获取到封装插件内部的数据（尤其是在周期函数中）
    + this->实例 ，在把一些常用的 信息 ，当作参数传递给回调函数
3. 可升级和可维护
    + 传递的配置参数基于对象管理
      1.0版本.  animate        2.0版本 effect:{...}
    + 我们新版本应该兼容老版本
      公司内部完全可以给定一个升级周期
    + 尽可能不要依赖于第三方
    + 如果有依赖，一定要把依赖的版本的明确
4. 代码的简介度和优化
    + 插件类库尽可能体积更小
    + 代码需要优化，不能消耗太多的性能
5. 尽可能代码通俗易懂，让别人读懂你的代码，而且还感觉很不错，是最厉害的事情
6. 团队协作开发一个插件 我们尽可能找到大家都熟知的技术栈、设计模式、代码编写方式
7. 分模块开发，基于webpack实现模块的合并
8. 开源