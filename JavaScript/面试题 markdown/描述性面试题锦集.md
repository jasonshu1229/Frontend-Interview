## 重绘和回流

### 重绘和回流它们分别是什么？

**重绘(repaint)**：当某一个DOM元素样式更改（不影响布局的样式更改）浏览器会重新渲染这个元素。

**回流(reflow)**：当页面的`布局`或`几何信息`发生变化，浏览器可能需要重新`创建DOM树`或者重新`计算`每一个元素在视口中的`位置`和`大小`(重新Layout)，重新计算完成后，让浏览器重新渲染。

> **回流必然会引起重绘**

### 哪些操作可能造成回流？

- DOM元素的`增删改`导致DOM结构变化
- DOM元素的`样式`（大小或位置）发生改变
- 浏览器窗口大小改变（视口改变导致元素位置改变）
- 页面第一次加载必然会有一次`回流`

### 如何避免回流和重绘？

主要避免DOM的回流：

1. 放弃操作DOM，改为`vue/react`数据影响视图模式的开发

2. 分离读写操作，样式集中改变（应用现代浏览器的渲染队列机制）

3. 元素批量修改（利用文档碎片`createDocumentFragment`和模板`字符串`拼接）

4. 对于`动画操作`或者`样式改变`，最好给元素添加`position: absolute/fixed`脱离文档流的css属性，

   再或者添加`opacity/filters`等这些可以让元素`分层渲染`的属性。

   因为它们可以优化回流的速度，拥有这些样式的元素，它们渲染的时候是分层渲染的，

   当我们再修改这些元素的样式时候，会在`重新Layout`和`渲染`的时候，`只对当前层进行处理`。

5. 更优化的手段：基于`transform`修改元素的样式，直接跳过了`Render Tree`和`Layout阶段`，直接把更改的样式告诉合成线程去渲染，不会引发回流，只是重绘而已（因为开启了渲染的硬件加速）

## Js延迟加载的方式有哪些？

js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。

方案如下：

- 将js脚本放在文档的底部，来使js脚本尽可能的在最后来加载执行。
- 给js脚本添加`async`属性，这个属性会使脚本`异步加载`，不会阻塞页面的解析过程，（原因是`async`是开辟HTTP线程加载资源文件，此时DOM TREE继续解析渲染，但是脚本文件加载完成后，立刻停止DOM TREE的渲染，先执行JS脚本代码，这个时候如果DOM TREE没有解析完成的话同样会阻塞）。多个`async`属性的脚本的执行顺序是不可预测的，不会按照脚本代码的顺序依次执行。
- 给js脚本添加`defer`属性，这个属性会使脚本的加载与DOM TREE的解析同步执行，会等到资源文件加载回来，DOM TREE树渲染完毕后，再执行JS脚本文件，这样的话就能使页面的渲染不被阻塞，（原因是`defer`也是开辟HTTP线程加载资源文件，但会等资源和DOM TREE都加载渲染完毕后，再执行JS脚本）。多个设置了`defer`属性的脚本会找顺序来依次执行。（排除个别浏览器）
- 动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。

## js 的几种模块规范？

js 中现在比较成熟的有四种模块加载方案：（AMD和CMD暂不做介绍）

- 第一种是CommonJS方案，它通过`require`来引入模块，通过`module.exports`定义模块的输出接口。这种模块加载方案是服务器端的加载方案，它是以`同步`的

  方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求因此使用异步加载的方式更加合适。

- 第二种是ES6提出的方案，使用`import`和`export`的形式导入导出模块。

## ES6 模块与 CommonJS 模块的差异？

- `CommonJS`模块输出的是一个值的拷贝，`ES6模块`输出的是值的引用。
  - 可理解为`CommonJS`一旦输出一个值，模块内部的变化就影响不到这个值。
  - `ES6模块`的运行机制与`CommonJS`不一样，JS引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的模块里面去取值。
- `CommonJS`模块是运行时加载，`ES6模块`是编译时输出接口。
  - `CommonJS`模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为`"运行时加载"`。
  - 而`ES6模块`不是对象，它的对外接口是一种静态定义，在代码静态解析阶段就会生成一个`只读引用`，所以`ES6模块`输出的是值的引用。
- `CommonJS`模块是同步导入，`ES6模块`是异步导入，这跟ES6模块通常用于web端，而CommonJS用于服务器端有关。

- `CommonJS`

## 哪些操作会造成内存泄漏？

- 意外的全局变量
  - 原因：该情况是由于我们使用`未声明`的变量，而意外的创建了一个全局变量，从而使这个变量一直留在内存中无法回收。

- 被遗忘的计时器或回调函数
  - 原因：由于设置了`setTimeout`定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，无法被回收。

- 脱离DOM的引用
  - 原因：当我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收

- 闭包
  - 原因：不合理的使用闭包，从而导致某些变量一直被留在内存中。

## v8是如何进行垃圾回收的？

JS引擎中对变量的存储主要有两种位置，栈内存和堆内存。

### 栈内存的回收

**栈内存调用栈上下文切换后，栈顶的空间就会自动被回收**。

### 堆内存的回收

v8把堆内存划分为两部分进行处理————**新生代内存**和**老生代内存**两个区域。

顾名思义，**新生代**就是临时分配的内存，存活时间短；**老生代**是常驻内存，存活的时间长。

#### 新生代内存的回收

v8的堆内存，也就是两个内存之和，由**新生代**和**老生代**共同组成。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gj0paxefmfj30k002y74g.jpg)

根据这两种不同种类的堆内存，v8采用了不同的回收策略，来根据不同的场景做针对性的优化。

**新生代**的垃圾回收是怎么做的呢？

首先将新生代内存空间一分为二，如图

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gj0pd7aobuj309l04amx6.jpg)

其中的From部分表示正在使用的内存，To是目前闲置的内存。

当进行垃圾回收时，v8将From部分的对象检查一遍

- 如果是**存活对象**，那么直接复制到To内存中（`在To内存中按照顺序从头放置的`）
- 如果是**非存活对象**，直接回收即可

当所有的From中的存活对象按照顺序进入到To内存之后，From和To两者的角色`对调`，From现在被闲置，To为正在使用，如此循环。

那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？

注意，我刚刚特别说明了，在To内存中按照顺序从头放置的，这是为了应对这样的场景:

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gj0ptvxq4vj308x04hdfu.jpg)

深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配， 这种零散的空间也叫做**内存碎片**。刚刚介绍的新生代垃圾回收算法也叫**Scavenge算法**。

Scavenge 算法主要就是解决**内存碎片**的问题，在进行一顿复制之后，To空间变成了这个样子:

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gj0puxyeq2j307s041mx4.jpg)

是不是整齐了许多？这样就大大方便了后续连续空间的分配。

不过Scavenge 算法的`劣势`也非常明显，就是**内存只能使用新生代内存的一半**，但是它只存放生命周期短的对象，这种对象`一般很少`，因此`时间`性能非常优秀。

#### 老生代内存的回收

刚刚介绍了新生代的回收方式，那么新生代中的变量**如果经过多次回收后依然存在**，那么就会被放入到`老生代内存`中，这种现象就叫`晋升`。

发生晋升其实不只是这一种原因，我们来梳理一下会有哪些情况触发`晋升`：

- 已经经历过一次Scavenge 回收。
- To（闲置）空间的内存占用超过25%。

现在进入到**老生代**的垃圾回收机制当中，**老生代**中累计的变量空间一般都是很大的，当然不能用`Scavenge`算法啦，因为它不仅会**浪费一半空间**，还会**对庞大的内存空间进行复制**呢。

那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？

「第一步」，进行`标记-清除`。主要分为两个阶段，即`标记阶段`和`清除阶段`。首先会遍历堆中的所有对象，对它们作上标记，然后对代码环境中`使用的变量`以及被`强引用`的变量取消标记（因为它们属于被引用对象），剩下的就是要删除的变量了，在随后的`清除阶段`对其进行空间的回收。

当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？

「第二步」，整理`内存碎片`。v8的解决方式非常简单粗暴，在`清除阶段`结束后，把存活的对象全部往一端靠拢。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gj0q4ppkp1j30c604njrf.jpg)

由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。

#### 增量标记

由于**JS的单线程机制**，V8 在进行垃圾回收的时候，不可避免地会**阻塞业务逻辑**的执行，倘若**老生代**的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。 那这个时候为了避免这样问题，V8 采取了`增量标记`的方案，**即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就"歇"一下，就js应用逻辑执行一会儿， 然后再执行下面的部分**，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像，这里就不展开了。

经过`增量标记`之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。

### 介绍一下引用计数和标记清楚

- `「引用计数」`：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为0的对象。但是当对象**循环引用**时，会导致引用次数永远无法归零，造成内存无法释放。
- `「标记清除」`：垃圾收集器先给 内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的，等待垃圾回收的对象。

### V8的垃圾回收是发生在什么时候？

浏览器渲染页面的空闲时间进行垃圾回收。